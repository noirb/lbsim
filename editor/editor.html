<!DOCTYPE html>
<!-- This is largely based on the voxel editor sample by mrdoob: http://threejs.org/examples/webgl_interactive_voxelpainter.html -->
<html lang="en">
    <head>
        <title>Simple Fluid Boundary Cell Editor v0.3</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                font-family: Monospace;
                background-color: #f0f0f0;
                margin: 0px;
                overflow: hidden;
            }

            #oldie { background-color: #ddd !important }
        </style>
    </head>
    <body>

            <div id="main">
            </div>

        <script src="three.min.js"></script>
        <script src="dat.gui.min.js"></script>
        <script src="detector.js"></script>

        <script>
            var version = 0.3;

            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

            function GuiManager() {
                this.name = "Name";
                this.BrushFlag = 'NO_SLIP';
                this.brushSize = 1;
                this.brushWidth = 1;
                this.brushOrientation = 'XZ';
                this.colors = { "NO_SLIP"       : 0x00ff00,
                                "FREE_SLIP"     : 0x0000ff,
                                "INFLOW"        : 0xff0000,
                                "OUTFLOW"       : 0xffff00,
                                "PRESSURE_IN"   : 0x00ffff,
                                "MOVING_WALL"   : 0xff00ff
                              }
                this.materials = {};

                // domain variables
                this.ScaleX = function () { rescaleX(); };
                this.ScaleY = function () { rescaleY(); };
                this.ScaleZ = function () { rescaleZ(); };
                this.xlength = 10;
                this.ylength = 10;
                this.zlength = 10;
                this.tau = 1.5;
                this.timesteps = 100;
                this.timestepsPerPlot = 10;

                this.parm1 = 0.0;
                this.parm2 = 0.0;
                this.parm3 = 0.0;

                // global flags for each exterior wall
                this.Xmin_Constant = true;
                this.Ymin_Constant = true;
                this.Zmin_Constant = true;
                this.Xmax_Constant = true;
                this.Ymax_Constant = true;
                this.Zmax_Constant = true;
                this.Xmin = 'NO_SLIP';
                this.Xmax = 'NO_SLIP';
                this.Ymin = 'NO_SLIP';
                this.Ymax = 'NO_SLIP';
                this.Zmin = 'NO_SLIP';
                this.Zmax = 'NO_SLIP';
                this.Xmin_p1 = "0"; this.Xmin_p2 = "0"; this.Xmin_p3 = "0";
                this.Ymin_p1 = "0"; this.Ymin_p2 = "0"; this.Ymin_p3 = "0";
                this.Zmin_p1 = "0"; this.Zmin_p2 = "0"; this.Zmin_p3 = "0";
                this.Xmax_p1 = "0"; this.Xmax_p2 = "0"; this.Xmax_p3 = "0";
                this.Ymax_p1 = "0"; this.Ymax_p2 = "0"; this.Ymax_p3 = "0";
                this.Zmax_p1 = "0"; this.Zmax_p2 = "0"; this.Zmax_p3 = "0";

                this.cellWidth = 50;
                this.halfCellWidth = this.cellWidth * 0.5;
                this.export = function () { ExportData(); };
            }

            function updateAllUIValues(ui)
            {
                for (var i in ui.__controllers)
                {
                    ui.__controllers[i].updateDisplay();
                }
                for (var f in ui.__folders)
                {
                    updateAllUIValues(ui.__folders[f]);
                }
            }

            var gui;
            var guiMgr = new GuiManager();
            var brushFlags = [ 'NO_SLIP', 'FREE_SLIP', 'INFLOW', 'OUTFLOW', 'PRESSURE_IN', 'MOVING_WALL' ];
            var container;
            var camera, scene, renderer;
            var plane, grid, cube;
            var mouse, raycaster, isShiftDown = false;

            var positionText = "(0,0,0)";
            var rollOverMesh, rollOverMaterial;
            var cubeGeo, noslipMaterial, freeslipMaterial, inflowMaterial, outflowMaterial, pressureinMaterial;

            var cameraParent;
            var cameraDist     = 1500;
            var cameraPosition = new THREE.Vector3();

            // png encoded in base64 to avoid needing to load an external file for textures (which can easily fail when running the page locally)
            var boxTexture = "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";

            var objects = [];
            var rollOverMeshes = [];

            init();
            render();


            /// ******************** ///
            /// -   ExportData()   - ///
            /// ******************** ///
            function ExportData()
            {
                var expData = "# Problem description generated by simple editor v" + version + "\n#- " + guiMgr.name.split(' ').join('_') + "\n";
                var xlength = guiMgr.xlength; var ylength = guiMgr.ylength; var zlength = guiMgr.zlength;

                // output domain parameters firs
                expData += "xlength \t" + guiMgr.xlength + "\n";
                expData += "ylength \t" + guiMgr.ylength + "\n";
                expData += "zlength \t" + guiMgr.zlength + "\n";
                expData += "tau \t\t" + guiMgr.tau + "\n";
                expData += "timesteps \t" + guiMgr.timesteps + "\n";
                expData += "timestepsPerPlotting \t" + guiMgr.timestepsPerPlot + "\n";

                // output cell data
                var children = scene.children;
                var voxels   = [];

                for( var i = 0; i < children.length; i++ ) {
                    var child = children[i];

                    if( child instanceof THREE.Mesh === false ) continue;
                    if( child.geometry instanceof THREE.BoxGeometry === false ) continue;
                    if( rollOverMeshes.indexOf(child) >= 0 ) continue;
                    var vPos = coord2ind(child.position.x, child.position.y, child.position.z);
                    voxels.push({
                        x     : vPos.x, //1 + (child.position.x - 25) / guiMgr.cellWidth,
                        y     : vPos.y, //1 + (child.position.y - 25) / guiMgr.cellWidth,
                        z     : vPos.z, //1 + (child.position.z - 25) / guiMgr.cellWidth,
                        f     : child.userData.flag,
                        parms : child.userData.parms
                    });
                }

                // open a window with the output-- must use base64 to preserve newline characters!
                var dataUri = "data:text/plain;charset=utf-8;base64,";
                expData += "\n# Cell Data for: " + guiMgr.name.split(' ').join('_') + "\n# Generated by simple editor v" + version + "\n\n";

                // handle wall auto-fills
                expData += "# Walls\n";

                // XMIN //
                if (guiMgr.Xmin_Constant)
                {
                    expData += "(0 * *) " + guiMgr.Xmin; // write coordinates and FLAG
                    // write constant coordinates
                    if (guiMgr.Xmin == 'MOVING_WALL' || guiMgr.Xmin == 'INFLOW')
                    {
                        expData += " (" + guiMgr.Xmin_p1 + " " + guiMgr.Xmin_p2 + " " + guiMgr.Xmin_p3 + ")";
                    }
                    else if (guiMgr.Xmin == 'PRESSURE_IN')
                    {
                        expData += " (" + guiMgr.Xmin_p1 + ")";
                    }
                    expData += "\n";
                }
                else
                {
                    expData += "# X Min wall parameterized with expressions\n";
                    expData += "#+ xmin_parm1: " + guiMgr.Xmin_p1 + "\n";
                    expData += "#+ xmin_parm2: " + guiMgr.Xmin_p2 + "\n";
                    expData += "#+ xmin_parm3: " + guiMgr.Xmin_p3 + "\n";
                    var x = 0;
                    for (var y = 0; y < guiMgr.ylength; y++)
                    {
                        for (var z = 0; z < guiMgr.zlength; z++)
                        {
                            expData += "(" + x + " " + y + " " + z + ") " + guiMgr.Xmin; // write coordinate and FLAG
                            // write evaluated parameters
                            if (guiMgr.Xmin == 'MOVING_WALL' || guiMgr.Xmin == 'INFLOW')
                            {
                                expData += " (" + eval(guiMgr.Xmin_p1) + " " + eval(guiMgr.Xmin_p2) + " " + eval(guiMgr.Xmin_p3) + ")";
                            }
                            else if (guiMgr.Xmin == 'PRESSURE_IN')
                            {
                                expData += " (" + eval(guiMgr.Xmin_p1) + ")";
                            }
                            expData += "\n";
                        }
                    }
                }

                // XMAX //
                if (guiMgr.Xmax_Constant)
                {
                    expData += "(N * *) " + guiMgr.Xmax;
                    if (guiMgr.Xmax == 'MOVING_WALL' || guiMgr.Xmax == 'INFLOW')
                    {
                        expData += " (" + guiMgr.Xmax_p1 + " " + guiMgr.Xmax_p2 + " " + guiMgr.Xmax_p3 + ")";
                    }
                    else if (guiMgr.Xmax == 'PRESSURE_IN')
                    {
                        expData += " (" + guiMgr.Xmax_p1 + ")";
                    }
                    expData += "\n";
                }
                else
                {
                    expData += "# X Max wall parameterized with expressions\n";
                    expData += "#+ xmax_parm1: " + guiMgr.Xmax_p1 + "\n";
                    expData += "#+ xmax_parm2: " + guiMgr.Xmax_p2 + "\n";
                    expData += "#+ xmax_parm3: " + guiMgr.Xmax_p3 + "\n";
                    var x = guiMgr.xlength;
                    for (var y = 0; y < guiMgr.ylength; y++)
                    {
                        for (var z = 0; z < guiMgr.zlength; z++)
                        {
                            expData += "(" + x + " " + y + " " + z + ") " + guiMgr.Xmax; // write coordinate and FLAG
                            // write evaluated parameters
                            if (guiMgr.Xmax == 'MOVING_WALL' || guiMgr.Xmax == 'INFLOW')
                            {
                                expData += " (" + eval(guiMgr.Xmax_p1) + " " + eval(guiMgr.Xmax_p2) + " " + eval(guiMgr.Xmax_p3) + ")";
                            }
                            else if (guiMgr.Xmin == 'PRESSURE_IN')
                            {
                                expData += " (" + eval(guiMgr.Xmax_p1) + ")";
                            }
                            expData += "\n";
                        }
                    }
                }

                // YMIN //
                if (guiMgr.Ymin_Constant)
                {
                    expData += "(* 0 *) " + guiMgr.Ymin;
                    if (guiMgr.Ymin == 'MOVING_WALL' || guiMgr.Ymin == 'INFLOW')
                    {
                        expData += " (" + guiMgr.Ymin_p1 + " " + guiMgr.Ymin_p2 + " " + guiMgr.Ymin_p3 + ")";
                    }
                    else if (guiMgr.Ymin == 'PRESSURE_IN')
                    {
                        expData += " (" + guiMgr.Ymin_p1 + ")";
                    }
                    expData += "\n";
                }
                else
                {
                    expData += "# Y Min wall parameterized with expressions\n";
                    expData += "#+ ymin_parm1: " + guiMgr.Ymin_p1 + "\n";
                    expData += "#+ ymin_parm2: " + guiMgr.Ymin_p2 + "\n";
                    expData += "#+ ymin_parm3: " + guiMgr.Ymin_p3 + "\n";
                    var y = 0;
                    for (var x = 0; x < guiMgr.xlength; x++)
                    {
                        for (var z = 0; z < guiMgr.zlength; z++)
                        {
                            expData += "(" + x + " " + y + " " + z + ") " + guiMgr.Ymin; // write coordinate and FLAG
                            // write evaluated parameters
                            if (guiMgr.Ymin == 'MOVING_WALL' || guiMgr.Ymin == 'INFLOW')
                            {
                                expData += " (" + eval(guiMgr.Ymin_p1) + " " + eval(guiMgr.Ymin_p2) + " " + eval(guiMgr.Ymin_p3) + ")";
                            }
                            else if (guiMgr.Ymin == 'PRESSURE_IN')
                            {
                                expData += " (" + eval(guiMgr.Ymin_p1) + ")";
                            }
                            expData += "\n";
                        }
                    }
                }

                // YMAX //
                if (guiMgr.Ymax_Constant)
                {
                    expData += "(* N *) " + guiMgr.Ymax;
                    if (guiMgr.Ymax == 'MOVING_WALL' || guiMgr.Ymax == 'INFLOW')
                    {
                        expData += " (" + guiMgr.Ymax_p1 + " " + guiMgr.Ymax_p2 + " " + guiMgr.Ymax_p3 + ")";
                    }
                    else if (guiMgr.Ymax == 'PRESSURE_IN')
                    {
                        expData += " (" + guiMgr.Ymax_p1 + ")";
                    }
                    expData += "\n";
                }
                else
                {
                    expData += "# Y Max wall parameterized with expressions\n";
                    expData += "#+ ymax_parm1: " + guiMgr.Ymax_p1 + "\n";
                    expData += "#+ ymax_parm2: " + guiMgr.Ymax_p2 + "\n";
                    expData += "#+ ymax_parm3: " + guiMgr.Ymax_p3 + "\n";
                    var y = guiMgr.ylength;
                    for (var x = 0; x < guiMgr.xlength; x++)
                    {
                        for (var z = 0; z < guiMgr.zlength; z++)
                        {
                            expData += "(" + x + " " + y + " " + z + ") " + guiMgr.Ymax; // write coordinate and FLAG
                            // write evaluated parameters
                            if (guiMgr.Ymax == 'MOVING_WALL' || guiMgr.Ymax == 'INFLOW')
                            {
                                expData += " (" + eval(guiMgr.Ymax_p1) + " " + eval(guiMgr.Ymax_p2) + " " + eval(guiMgr.Ymax_p3) + ")";
                            }
                            else if (guiMgr.Ymax == 'PRESSURE_IN')
                            {
                                expData += " (" + eval(guiMgr.Ymax_p1) + ")";
                            }
                            expData += "\n";
                        }
                    }
                }

                // ZMIN //
                if (guiMgr.Zmin_Constant)
                {
                    expData += "(* * 0) " + guiMgr.Zmin;
                    if (guiMgr.Zmin == 'MOVING_WALL' || guiMgr.Zmin == 'INFLOW')
                    {
                        expData += " (" + guiMgr.Zmin_p1 + " " + guiMgr.Zmin_p2 + " " + guiMgr.Zmin_p3 + ")";
                    }
                    else if (guiMgr.Zmin == 'PRESSURE_IN')
                    {
                        expData += " (" + guiMgr.Zmin_p1 + ")";
                    }
                    expData += "\n";
                }
                else
                {
                    expData += "# Z Min wall parameterized with expressions\n";
                    expData += "#+ zmin_parm1: " + guiMgr.Zmin_p1 + "\n";
                    expData += "#+ zmin_parm2: " + guiMgr.Zmin_p2 + "\n";
                    expData += "#+ zmin_parm3: " + guiMgr.Zmin_p3 + "\n";
                    var z = 0;
                    for (var x = 0; x < guiMgr.xlength; x++)
                    {
                        for (var y = 0; y < guiMgr.ylength; y++)
                        {
                            expData += "(" + x + " " + y + " " + z + ") " + guiMgr.Zmin; // write coordinate and FLAG
                            // write evaluated parameters
                            if (guiMgr.Zmin == 'MOVING_WALL' || guiMgr.Zmin == 'INFLOW')
                            {
                                expData += " (" + eval(guiMgr.Zmin_p1) + " " + eval(guiMgr.Zmin_p2) + " " + eval(guiMgr.Zmin_p3) + ")";
                            }
                            else if (guiMgr.Zmin == 'PRESSURE_IN')
                            {
                                expData += " (" + eval(guiMgr.Zmin_p1) + ")";
                            }
                            expData += "\n";
                        }
                    }
                }

                // ZMAX //
                if (guiMgr.Zmax_Constant)
                {
                    expData += "(* * N) " + guiMgr.Zmax;
                    if (guiMgr.Zmax == 'MOVING_WALL' || guiMgr.Zmax == 'INFLOW')
                    {
                        expData += " (" + guiMgr.Zmax_p1 + " " + guiMgr.Zmax_p2 + " " + guiMgr.Zmax_p3 + ")";
                    }
                    else if (guiMgr.Zmax == 'PRESSURE_IN')
                    {
                        expData += " (" + guiMgr.Zmax_p1 + ")";
                    }
                    expData += "\n";
                }
                else
                {
                    expData += "# Z Max wall parameterized with expressions\n";
                    expData += "#+ zmax_parm1: " + guiMgr.Zmax_p1 + "\n";
                    expData += "#+ zmax_parm2: " + guiMgr.Zmax_p2 + "\n";
                    expData += "#+ zmax_parm3: " + guiMgr.Zmax_p3 + "\n";
                    var z = guiMgr.zlength;
                    for (var x = 0; x < guiMgr.xlength; x++)
                    {
                        for (var y = 0; y < guiMgr.ylength; y++)
                        {
                            expData += "(" + x + " " + y + " " + z + ") " + guiMgr.Zmax; // write coordinate and FLAG
                            // write evaluated parameters
                            if (guiMgr.Zmax == 'MOVING_WALL' || guiMgr.Zmax == 'INFLOW')
                            {
                                expData += " (" + eval(guiMgr.Zmax_p1) + " " + eval(guiMgr.Zmax_p2) + " " + eval(guiMgr.Zmax_p3) + ")";
                            }
                            else if (guiMgr.Zmax == 'PRESSURE_IN')
                            {
                                expData += " (" + eval(guiMgr.Zmax_p1) + ")";
                            }
                            expData += "\n";
                        }
                    }
                }

                expData += "\n";

                expData += "# Individual cells\n";
                for ( var i = 0; i < voxels.length; i++)
                {
                    expData += "(" + voxels[i].x + " " + voxels[i].y + " " + voxels[i].z + ") " + voxels[i].f;
                    expData += SerializeParams(voxels[i].parms);
                    expData += "\n";
                }
                dataUri += btoa(expData);
                window.open( dataUri, 'mywindow' );
            }
            

            function SerializeParams(parameters)
            {
                result = "";
                if (parameters.length > 0)
                {
                    result += " (";
                    for ( var p = 0; p < parameters.length; p++ )
                    {
                        result += parameters[p];

                        if ( p < parameters.length - 1) // only add a space if this not the last parameter
                        {
                            result += " ";
                        }
                    }
                    result += ")";
                }

                return result;
            }

            /// ******************** ///
            /// -   ImportData()   - ///
            /// ******************** ///
            function ImportData(data)
            {
                var cell_regex = /\((\*|[nN]|[0-9]+) +(\*|[nN]|[0-9]+) +(\*|[nN]|[0-9]+)\) +([A-Z]+_*[A-Z]*) *(\((-?[0-9]+\.[0-9]+|-?[0-9]+) *(-?[0-9]+\.[0-9]+|-?[0-9]+)? *(-?[0-9]+\.[0-9]+|-?[0-9]+)?\))?/;
                var lines = data.split("\n");
                var minx_expr = false; var maxx_expr = false; var miny_expr = false; var maxy_expr = false; var minz_expr = false; var maxz_expr = false;
                // empty scene of any existing voxels
                var children = objects; //scene.children;
                for( var i = children.length; i >= 0; --i ) {
                    var child = children[i];
                    if( child instanceof THREE.Mesh === false ) continue;
                    if( child.geometry instanceof THREE.BoxGeometry === false ) continue;
                    if( rollOverMeshes.indexOf(child) >= 0 ) continue;

                    objects.splice( objects.indexOf( child ), 1 );
                    scene.remove( child );
                }

                // parse each line to set up the scene
                for ( var i = 0; i < lines.length; i++ )
                {
                    // try to match cell data & add a voxel
                    var matches = cell_regex.exec(lines[i]);
                    if (matches)
                    {
                        var px = null; var py = null; var pz = null;

                        // get position
                        var cx = matches[1];
                        var cy = matches[2];
                        var cz = matches[3];

                        // get flag
                        var cf = matches[4];

                        // check for parameters
                        if (matches[5])
                        {
                            px = matches[6];
                            py = matches[7];
                            pz = matches[8];
                            //console.log("Found: [" + cx + ", " + cy + ", " + cz + "] : " + cf + " <" + px + ", " + py + ", " + pz + ">");
                        }
                        else
                        {
                            //console.log("Found: [" + cx + ", " + cy + ", " + cz + "] : " + cf);
                        }

                        // deal with borders & wildcards                                /// TODO : CLEAN THIS MESS UP
                        if (cx == "*" || cy == "*" || cz == "*" ||
                            cx.toUpperCase() == "N" || cy.toUpperCase() == "N" || cz.toUpperCase() == "N" ||
                            cx == "0" || cy == "0" || cz == "0" ||
                            cx == guiMgr.xlength || cy == guiMgr.ylength || cz == guiMgr.zlength)
                        {
                            var wallstr = (cx + cy + cz).toUpperCase();
                            switch (wallstr)
                            {
                                case "**0": // minz
                                    guiMgr.Zmin_Constant = true; 
                                    guiMgr.Zmin = cf;
                                    if (minz_expr) { break; } // don't load this cell's values as parameters if we have an expression
                                    if (px) { guiMgr.Zmin_p1 = parseFloat(px); }
                                    if (py) { guiMgr.Zmin_p2 = parseFloat(py); }
                                    if (pz) { guiMgr.Zmin_p3 = parseFloat(pz); }
                                    break;
                                case "*0*": // miny
                                    guiMgr.Ymin_Constant = true;
                                    guiMgr.Ymin = cf;
                                    if (miny_expr) { break; } // don't load this cell's values as parameters if we have an expression
                                    if (px) { guiMgr.Ymin_p1 = parseFloat(px); }
                                    if (py) { guiMgr.Ymin_p2 = parseFloat(py); }
                                    if (pz) { guiMgr.Ymin_p3 = parseFloat(pz); }
                                    break
                                case "0**": // minx
                                    guiMgr.Xmin_Constant = true;
                                    guiMgr.Xmin = cf;
                                    if (minx_expr) { break; } // don't load this cell's values as parameters if we have an expression
                                    if (px) { guiMgr.Xmin_p1 = parseFloat(px); }
                                    if (py) { guiMgr.Xmin_p2 = parseFloat(py); }
                                    if (pz) { guiMgr.Xmin_p3 = parseFloat(pz); }
                                    break
                                case "**N": // maxz
                                    guiMgr.Zmax_Constant = true;
                                    guiMgr.Zmax = cf;
                                    if (maxz_expr) { break; } // don't load this cell's values as parameters if we have an expression
                                    if (px) { guiMgr.Zmax_p1 = parseFloat(px); }
                                    if (py) { guiMgr.Zmax_p2 = parseFloat(py); }
                                    if (pz) { guiMgr.Zmax_p3 = parseFloat(pz); }
                                    break;
                                case "*N*": // maxy
                                    guiMgr.Ymax_Constant = true;
                                    guiMgr.Ymax = cf;
                                    if (maxy_expr) { break; } // don't load this cell's values as parameters if we have an expression
                                    if (px) { guiMgr.Ymax_p1 = parseFloat(px); }
                                    if (py) { guiMgr.Ymax_p2 = parseFloat(py); }
                                    if (pz) { guiMgr.Ymax_p3 = parseFloat(pz); }
                                    break;
                                case "N**": // maxx
                                    guiMgr.Xmax_Constant = true;
                                    guiMgr.Xmax = cf;
                                    if (maxx_expr) { break; } // don't load this cell's values as parameters if we have an expression
                                    if (px) { guiMgr.Xmax_p1 = parseFloat(px); }
                                    if (py) { guiMgr.Xmax_p2 = parseFloat(py); }
                                    if (pz) { guiMgr.Xmax_p3 = parseFloat(pz); }
                                    break;
                                default: // not a wild card, just a cell on a wall
                                    if (cx == 0)
                                    {
                                        guiMgr.Xmin_Constant = false;
                                        guiMgr.Xmin = cf;
                                    }
                                    else if (cy == 0)
                                    {
                                        guiMgr.Ymin_Constant = false;
                                        guiMgr.Ymin = cf;
                                    }
                                    else if (cz == 0)
                                    {
                                        guiMgr.Zmin_Constant = false;
                                        guiMgr.Zmin = cf;
                                    }
                                    else if (cx == guiMgr.xlength)
                                    {
                                        guiMgr.Xmax_Constant = false;
                                        guiMgr.Xmax = cf;
                                    }
                                    else if (cy == guiMgr.ylength)
                                    {
                                        guiMgr.Ymax_Constant = false;
                                        guiMgr.Ymax = cf;
                                    }
                                    else if (cz == guiMgr.zlength)
                                    {
                                        guiMgr.Zmax_Constant = false;
                                        guiMgr.Zmax = cf;
                                    }
                                    break;
                            }
                            continue;
                        }

                        // create the voxel
                        var voxPos = ind2coord(cx, cy, cz);
                        var voxel = new THREE.Mesh( cubeGeo, guiMgr.materials[cf] );
                        voxel.position.copy( voxPos );
                        voxel.material.color.setHex(guiMgr.colors[cf]);

                        // store cell data for later export
                        voxel.userData.flag = cf;     // FLAG

                        // only store parameter data for flags that require it
                        switch (cf)
                        {
                            case 'MOVING_WALL':
                                voxel.userData.parms = [px, py, pz];
                                break;
                            case 'INFLOW':
                                voxel.userData.parms = [px, py, pz];
                                break;
                            case 'PRESSURE_IN':
                                voxel.userData.parms = [px];
                                break;
                            default:
                                voxel.userData.parms = [];
                                break;
                        }

                        scene.add( voxel );
                        objects.push( voxel );
                    }
                    else // if current line didn't have cell data, it might have a domain parameter
                    {
                        var ls = lines[i].match(/\S+/g);
                        if (ls) // found something other that whitespace
                        {
                            // ignore commented lines
                            if (ls[0] == "#")
                            {
                                continue;
                            }
                            else if (ls[0] == "#-") // should do this differently...
                            {
                                guiMgr.name = ls[1];
                            }
                            else if (ls[0] == "#+") // found a paramater expression
                            {
                                parseParameterExpression(lines[i]);
                            }
                            else if (ls[0] == "xlength")
                            {
                                guiMgr.xlength = parseInt(ls[1]);
                            }
                            else if (ls[0] == "ylength")
                            {
                                guiMgr.ylength = parseInt(ls[1]);
                            }
                            else if (ls[0] == "zlength")
                            {
                                guiMgr.zlength = parseInt(ls[1]);
                            }
                            else if (ls[0] == "tau")
                            {
                                guiMgr.tau = parseFloat(ls[1]);
                            }
                            else if (ls[0] == "timesteps")
                            {
                                guiMgr.timesteps = parseInt(ls[1]);
                            }
                            else if (ls[0] == "timestepsPerPlotting")
                            {
                                guiMgr.timestepsPerPlot = parseInt(ls[1]);
                            }
                        }
                    }
                }

                // update UI controls to reflect any changes
                updateAllUIValues(gui);
                resizeDomain();
                render();
            }

            function parseParameterExpression(paramString)
            {
                var paramRegex = /\#\+ (\S+): (.+)/g;
                var expr = paramRegex.exec(paramString);
                switch(expr[1])
                {
                    case "xmin_parm1" : guiMgr.Xmin_p1 = expr[2]; break;
                    case "xmin_parm2" : guiMgr.Xmin_p2 = expr[2]; break;
                    case "xmin_parm3" : guiMgr.Xmin_p3 = expr[2]; break;

                    case "xmax_parm1" : guiMgr.Xmax_p1 = expr[2]; break;
                    case "xmax_parm2" : guiMgr.Xmax_p2 = expr[2]; break;
                    case "xmax_parm3" : guiMgr.Xmax_p3 = expr[2]; break;

                    case "ymin_parm1" : guiMgr.Ymin_p1 = expr[2]; break;
                    case "ymin_parm2" : guiMgr.Ymin_p2 = expr[2]; break;
                    case "ymin_parm3" : guiMgr.Ymin_p3 = expr[2]; break;

                    case "ymax_parm1" : guiMgr.Ymax_p1 = expr[2]; break;
                    case "ymax_parm2" : guiMgr.Ymax_p2 = expr[2]; break;
                    case "ymax_parm3" : guiMgr.Ymax_p3 = expr[2]; break;

                    case "zmin_parm1" : guiMgr.Zmin_p1 = expr[2]; break;
                    case "zmin_parm2" : guiMgr.Zmin_p2 = expr[2]; break;
                    case "zmin_parm3" : guiMgr.Zmin_p3 = expr[2]; break;

                    case "zmax_parm1" : guiMgr.Zmax_p1 = expr[2]; break;
                    case "zmax_parm2" : guiMgr.Zmax_p2 = expr[2]; break;
                    case "zmax_parm3" : guiMgr.Zmax_p3 = expr[2]; break;
                }
            }

            // changes brush size
            function setBrushSize(newSize)
            {
                // remove all rollovermeshes
                for (var i = rollOverMeshes.length -1; i >= 0; i--)
                {
                    scene.remove(rollOverMeshes[i]);
                    rollOverMeshes.splice( i, 1 );
                }

                // add newSize x newSize new rollovermeshes
                for (var i = 0; i < newSize; i++)
                {
                    for (var j = 0; j < newSize; j++)
                    {
                        for (var k = 0; k < guiMgr.brushWidth; k++)
                        {
                            var newRollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
                            scene.add( newRollOverMesh );
                            rollOverMeshes.push( newRollOverMesh );
                        }
                    }
                }
                render();
            }

            function setBrushWidth(newWidth)
            {
                setBrushSize(guiMgr.brushSize);
            }

            function setBrushOrientation(newOrientation)
            {

            }

            // resizes the grid when xlength, ylength, or zlength changes
            function resizeDomain()
            {
                if (guiMgr.xlength < 1) { guiMgr.xlength = 1; updateAllUIValues(gui); }
                if (guiMgr.ylength < 1) { guiMgr.ylength = 1; updateAllUIValues(gui); }
                if (guiMgr.zlength < 1) { guiMgr.zlength = 1; updateAllUIValues(gui); }

                scene.remove(grid);
                scene.remove(plane);

                grid = new THREE.Mesh( new THREE.PlaneGeometry( guiMgr.xlength*guiMgr.cellWidth, guiMgr.zlength*guiMgr.cellWidth, guiMgr.xlength, guiMgr.zlength ), new THREE.MeshBasicMaterial( { color: 0x0066aa, wireframe: true } ) );
                grid.rotation.x = - 90 * Math.PI / 180;
                grid.position.set(guiMgr.xlength * guiMgr.cellWidth * 0.5, 0, guiMgr.zlength * guiMgr.cellWidth * 0.5);
                scene.add(grid);

                var geometry = new THREE.PlaneBufferGeometry( guiMgr.cellWidth * guiMgr.xlength, guiMgr.cellWidth * guiMgr.zlength );
                geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
                plane = new THREE.Mesh( geometry );
                plane.visible = false;
                plane.position.set(guiMgr.xlength * guiMgr.cellWidth * 0.5, 0, guiMgr.zlength * guiMgr.cellWidth * 0.5);
                scene.add(plane);
                objects.push(plane);

                updateCameraPos();

                render();
            }

            function rescaleDomain(xScale, yScale, zScale)
            {
                var scaleMat = new THREE.Matrix4();
                scaleMat.makeScale(xScale, yScale, zScale);
                scaleMat.getInverse(scaleMat);
                guiMgr.xlength = Math.max(Math.round(guiMgr.xlength * xScale), 1);
                guiMgr.ylength = Math.max(Math.round(guiMgr.ylength * yScale), 1);
                guiMgr.zlength = Math.max(Math.round(guiMgr.zlength * zScale), 1);

                resizeDomain();
                updateAllUIValues(gui);

                // loop over domain to find cells we need to place new voxels in
                var newPoints = [];
                for (var i = 0; i < guiMgr.xlength; i++)
                {
                    for (var j = 0; j < guiMgr.ylength; j++)
                    {
                        for (var k = 0; k < guiMgr.zlength; k++)
                        {
                            var v = ind2coord(i, j, k);
                            var sv = new THREE.Vector3(v.x, v.y, v.z);
                            sv.x *= 1.0 / xScale;
                            sv.y *= 1.0 / yScale;
                            sv.z *= 1.0 / zScale;
                            for (var o = 0; o < objects.length; o++)
                            {
                                if (objects[o].position.distanceTo(sv) <= guiMgr.halfCellWidth)
                                {
                                    newPoints.push({ pos: v, dat: objects[o].userData});
                                    break;
                                }
                            }
                        }
                    }
                }

                // clear existing voxels
                var children = objects; //scene.children;
                for( var i = children.length; i >= 0; --i ) {
                    var child = children[i];
                    if( child instanceof THREE.Mesh === false ) continue;
                    if( child.geometry instanceof THREE.BoxGeometry === false ) continue;
                    if( rollOverMeshes.indexOf(child) >= 0 ) continue;

                    objects.splice( objects.indexOf( child ), 1 );
                    scene.remove( child );
                }

                // add voxels at all new points
                for (var i = 0; i < newPoints.length; i++)
                {
                    var voxel = new THREE.Mesh( cubeGeo, guiMgr.materials[newPoints[i].dat.flag] );
                    voxel.position.copy( newPoints[i].pos );
                    voxel.position.divideScalar( guiMgr.cellWidth ).floor().multiplyScalar( guiMgr.cellWidth ).addScalar( guiMgr.halfCellWidth );
                    voxel.userData = newPoints[i].dat;
                    voxel.material.color.setHex(guiMgr.colors[voxel.userData.flag]);

                    // don't actually add voxel if it's outside our domain
                    if ((voxel.position.x - (guiMgr.halfCellWidth)) / guiMgr.cellWidth >= guiMgr.xlength)
                        continue;
                    if ((voxel.position.y - (guiMgr.halfCellWidth)) / guiMgr.cellWidth >= guiMgr.ylength)
                        continue;
                    if ((voxel.position.z - (guiMgr.halfCellWidth)) / guiMgr.cellWidth >= guiMgr.zlength)
                        continue;
                    if ((voxel.position.x < 0) || (voxel.position.y < 0) || (voxel.position.z < 0))
                        continue;

                    // only store parameter data for flags that require it
                    switch (guiMgr.BrushFlag)
                    {
                        case 'MOVING_WALL':
                            voxel.userData.parms = [guiMgr.parm1, guiMgr.parm2, guiMgr.parm3];
                            break;
                        case 'INFLOW':
                            voxel.userData.parms = [guiMgr.parm1, guiMgr.parm2, guiMgr.parm3];
                            break;
                        case 'PRESSURE_IN':
                            voxel.userData.parms = [guiMgr.parm1];
                            break;
                        default:
                            voxel.userData.parms = [];
                            break;
                    }

                    scene.add( voxel );
                    objects.push( voxel );
                }
                updateCameraPos();
                render();
            }

            function rescaleX()
            {
                var scaleFactor = window.prompt("Scale X by percentage:", "100");
                if (scaleFactor) // ensure user entered a value
                {
                    scaleFactor = parseFloat(scaleFactor) / 100.0;
                    rescaleDomain(scaleFactor, 1.0, 1.0);

                }
            }

            function rescaleY()
            {
                var scaleFactor = window.prompt("Scale Y by percentage:", "100");
                if (scaleFactor) // ensure user entered a value
                {
                    scaleFactor = parseFloat(scaleFactor) / 100.0;
                    rescaleDomain(1.0, scaleFactor, 1.0);
                }
            }

            function rescaleZ()
            {
                var scaleFactor =    window.prompt("Scale Z by percentage:", "100");
                if (scaleFactor) // ensure user entered a value
                {
                    scaleFactor = parseFloat(scaleFactor) / 100.0;
                    rescaleDomain(1.0, 1.0, scaleFactor);
                }
            }

            function getDomainCenter()
            {
                return new THREE.Vector3(guiMgr.xlength * guiMgr.cellWidth * 0.5 + guiMgr.halfCellWidth,
                                         guiMgr.ylength * guiMgr.cellWidth * 0.5 + guiMgr.halfCellWidth,
                                         guiMgr.zlength * guiMgr.cellWidth * 0.5 + guiMgr.halfCellWidth);
            }

            // converts an integer index (from .dat file) to world-space coordinates
            function ind2coord(ix, iy, iz)
            {
                var result = new THREE.Vector3;
                result.setX( (ix-1) * guiMgr.cellWidth + guiMgr.halfCellWidth );
                result.setY( (iy-1) * guiMgr.cellWidth + guiMgr.halfCellWidth );
                result.setZ( (iz-1) * guiMgr.cellWidth + guiMgr.halfCellWidth );
                return result;
            }

            // converts world-space coordinates to integer indices (for export to .dat)
            function coord2ind(x, y, z)
            {
                var result = {x: -1, y: -1, z: -1};
                result.x = 1 + (x - guiMgr.halfCellWidth) / guiMgr.cellWidth;
                result.y = 1 + (y - guiMgr.halfCellWidth) / guiMgr.cellWidth;
                result.z = 1 + (z - guiMgr.halfCellWidth) / guiMgr.cellWidth;
                return result;
            }

            function init() {
                // set up GUI
                gui = new dat.GUI();
                gui.add(guiMgr, 'name');
                gui.add(guiMgr, 'BrushFlag', brushFlags);
                gui.add(guiMgr, 'brushSize', 1, 100).step(1).onFinishChange( function(newValue) { setBrushSize(newValue); });
                gui.add(guiMgr, 'brushWidth', 1, 20).step(1).onFinishChange( function(newValue) { setBrushWidth(newValue); });
                gui.add(guiMgr, 'brushOrientation', {XZ: 'XZ', XY: 'XY', YZ: 'YZ'}).onFinishChange( function(newValue) { setBrushOrientation(newValue); });
                var domainFolder = gui.addFolder('Domain Settings');
                domainFolder.add(guiMgr, 'ScaleX');
                domainFolder.add(guiMgr, 'ScaleY');
                domainFolder.add(guiMgr, 'ScaleZ');
                domainFolder.add(guiMgr, 'xlength').onFinishChange( function(newValue) { resizeDomain(); });
                domainFolder.add(guiMgr, 'ylength').onFinishChange( function(newValue) { resizeDomain(); });
                domainFolder.add(guiMgr, 'zlength').onFinishChange( function(newValue) { resizeDomain(); });
                domainFolder.add(guiMgr, 'tau', 0.5, 2.0);
                domainFolder.add(guiMgr, 'timesteps');
                domainFolder.add(guiMgr, 'timestepsPerPlot');

                var wallFolder = gui.addFolder('Wall Settings');

                wallFolder.add(guiMgr, 'Xmin', brushFlags);
                var xminFolder = wallFolder.addFolder('X Min Parameters');
                xminFolder.add(guiMgr, 'Xmin_Constant');
                xminFolder.add(guiMgr, 'Xmin_p1'); //.step(0.001);
                xminFolder.add(guiMgr, 'Xmin_p2'); //.step(0.001);
                xminFolder.add(guiMgr, 'Xmin_p3'); //.step(0.001);

                wallFolder.add(guiMgr, 'Xmax', brushFlags);
                var xmaxFolder = wallFolder.addFolder('X Max Parameters');
                xmaxFolder.add(guiMgr, 'Xmax_Constant');
                xmaxFolder.add(guiMgr, 'Xmax_p1'); //.step(0.001);
                xmaxFolder.add(guiMgr, 'Xmax_p2'); //.step(0.001);
                xmaxFolder.add(guiMgr, 'Xmax_p3'); //.step(0.001);

                wallFolder.add(guiMgr, 'Ymin', brushFlags);
                var yminFolder = wallFolder.addFolder('Y Min Parameters');
                yminFolder.add(guiMgr, 'Ymin_Constant');
                yminFolder.add(guiMgr, 'Ymin_p1'); //.step(0.001);
                yminFolder.add(guiMgr, 'Ymin_p2'); //.step(0.001);
                yminFolder.add(guiMgr, 'Ymin_p3'); //.step(0.001);

                wallFolder.add(guiMgr, 'Ymax', brushFlags);
                var ymaxFolder = wallFolder.addFolder('Y Max Parameters');
                ymaxFolder.add(guiMgr, 'Ymax_Constant');
                ymaxFolder.add(guiMgr, 'Ymax_p1'); //.step(0.001);
                ymaxFolder.add(guiMgr, 'Ymax_p2'); //.step(0.001);
                ymaxFolder.add(guiMgr, 'Ymax_p3'); //.step(0.001);

                wallFolder.add(guiMgr, 'Zmin', brushFlags);
                var zminFolder = wallFolder.addFolder('Z Min Parameters');
                zminFolder.add(guiMgr, 'Zmin_Constant');
                zminFolder.add(guiMgr, 'Zmin_p1'); //.step(0.001);
                zminFolder.add(guiMgr, 'Zmin_p2'); //.step(0.001);
                zminFolder.add(guiMgr, 'Zmin_p3'); //.step(0.001);

                wallFolder.add(guiMgr, 'Zmax', brushFlags);
                var zmaxFolder = wallFolder.addFolder('Z Max Parameters');
                zmaxFolder.add(guiMgr, 'Zmax_Constant');
                zmaxFolder.add(guiMgr, 'Zmax_p1'); //.step(0.001);
                zmaxFolder.add(guiMgr, 'Zmax_p2'); //.step(0.001);
                zmaxFolder.add(guiMgr, 'Zmax_p3'); //.step(0.001);

                var parmFolder = gui.addFolder('Cell Parameters');
                parmFolder.add(guiMgr, 'parm1').step(0.001);
                parmFolder.add(guiMgr, 'parm2').step(0.001);
                parmFolder.add(guiMgr, 'parm3').step(0.001);
                gui.add(guiMgr, 'export');

                // END gui setup

                container = document.getElementById('main');

                // Help text (to display controls, etc)
                var info = document.createElement( 'div' );
                info.style.position = 'absolute';
                info.style.top = '10px';
                info.style.width = '100%';
                info.style.textAlign = 'center';
                info.style.color = '#afb';
                info.innerHTML  = '<strong>click</strong>: add voxel, <strong>shift + click</strong>: remove voxel<br /><strong>Arrow Keys</strong>: rotate camera, <strong>WSAD:</strong> pan camera, <strong>Q,E:</strong> move up/down<br />';
                info.innerHTML += '<div id="position" style="font-weight:bold; color: #ff9;">(0,0,0)</div>';
                container.appendChild( info );

                // camera setup
                cameraParent = new THREE.Object3D();
                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
                camera.position.set( cameraDist, cameraDist, cameraDist );
                camera.lookAt( getDomainCenter() );
                cameraParent.add(camera);
                updateCameraPos();

                // scene setup
                scene = new THREE.Scene();
                scene.add(cameraParent);
                cameraParent.position.set( guiMgr.xlength * guiMgr.halfCellWidth, guiMgr.ylength * guiMgr.halfCellWidth, guiMgr.zlength * guiMgr.halfCellWidth);

                // roll-over helpers
                rollOverGeo = new THREE.BoxGeometry( guiMgr.cellWidth, guiMgr.cellWidth, guiMgr.cellWidth );
                rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );
                var newRollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
                scene.add( newRollOverMesh );
                rollOverMeshes.push( newRollOverMesh );

                // cubes
                var txImage = document.createElement('img');
                var texture = new THREE.Texture(txImage);
                txImage.onload = function() { texture.needsUpdate = true; };
                txImage.src = 'data:image/png;base64,' + boxTexture;
                cubeGeo = new THREE.BoxGeometry( guiMgr.cellWidth, guiMgr.cellWidth, guiMgr.cellWidth );
                guiMgr.materials['NO_SLIP']     = new THREE.MeshLambertMaterial( { color: guiMgr.colors['NO_SLIP'], shading: THREE.FlatShading, map: texture } );
                guiMgr.materials['FREE_SLIP']   = new THREE.MeshLambertMaterial( { color: guiMgr.colors['FREE_SLIP'], shading: THREE.FlatShading, map: texture } );
                guiMgr.materials['INFLOW']      = new THREE.MeshLambertMaterial( { color: guiMgr.colors['INFLOW'], shading: THREE.FlatShading, map: texture } );
                guiMgr.materials['OUTFLOW']     = new THREE.MeshLambertMaterial( { color: guiMgr.colors['OUTFLOW'], shading: THREE.FlatShading, map: texture } );
                guiMgr.materials['PRESSURE_IN'] = new THREE.MeshLambertMaterial( { color: guiMgr.colors['PRESSURE_IN'], shading: THREE.FlatShading, map: texture } );
                guiMgr.materials['MOVING_WALL'] = new THREE.MeshLambertMaterial( { color: guiMgr.colors['MOVING_WALL'], shading: THREE.FlatShading, map: texture } );

                // grid
                grid = new THREE.Mesh( new THREE.PlaneGeometry( guiMgr.xlength*guiMgr.cellWidth, guiMgr.zlength*guiMgr.cellWidth, guiMgr.xlength, guiMgr.zlength ), new THREE.MeshBasicMaterial( { color: 0x0066aa, wireframe: true } ) );
                grid.rotation.x = - 90 * Math.PI / 180;
                grid.position.set(guiMgr.xlength * guiMgr.halfCellWidth, 0, guiMgr.zlength * guiMgr.halfCellWidth);
                scene.add( grid );

                // raycaster & mouse are used for input tests
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();

                // invisible plane for intersection checks w/ mouse vector
                var geometry = new THREE.PlaneBufferGeometry( guiMgr.cellWidth * guiMgr.xlength, guiMgr.cellWidth * guiMgr.zlength );
                geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
                plane = new THREE.Mesh( geometry );
                plane.visible = false;
                plane.position.set(guiMgr.xlength * guiMgr.halfCellWidth, 0, guiMgr.zlength * guiMgr.halfCellWidth);
                scene.add( plane );
                objects.push( plane );

                // Lights
                var ambientLight = new THREE.AmbientLight( 0x606060 );
                scene.add( ambientLight );

                var directionalLight = new THREE.DirectionalLight( 0xffffff );
                directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
                scene.add( directionalLight );

                // renderer setup
                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setClearColor( 0x202020 );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                container.appendChild( renderer.domElement );

                // input events
                renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
                renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
                document.addEventListener( 'keydown', onDocumentKeyDown, false );
                document.addEventListener( 'keyup', onDocumentKeyUp, false );
                document.addEventListener( 'drop', onDocumentDrop, false);
                document.addEventListener( 'dragover', onDocumentDragOver, false);

                window.addEventListener( 'resize', onWindowResize, false );
            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            function onDocumentMouseMove( event ) {
                event.preventDefault();

                mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

                // get world position of camera to raycast from
                cameraPosition.setFromMatrixPosition( camera.matrixWorld );
                raycaster.ray.origin.copy(cameraPosition);
                raycaster.ray.direction.set(mouse.x, mouse.y, 0.5).unproject(camera).sub(cameraPosition).normalize();

                var intersects = raycaster.intersectObjects( objects );

                if ( intersects.length > 0 ) {
                    var intersect = intersects[ 0 ];
                    rollOverMaterial.color.setHex(guiMgr.colors[guiMgr.BrushFlag]);
                    for (var i = 0; i < guiMgr.brushSize; i++)
                    {
                        for (var j = 0; j < guiMgr.brushSize; j++)
                        {
                            for (var k = 0; k < guiMgr.brushWidth; k++)
                            {
                                var offset;
                                switch (guiMgr.brushOrientation)
                                {
                                    case 'XZ':
                                        offset = new THREE.Vector3(guiMgr.cellWidth * (0.5 + i - guiMgr.brushSize * 0.5), guiMgr.cellWidth * k, guiMgr.cellWidth * (0.5 + j - guiMgr.brushSize * 0.5));
                                        break;
                                    case 'XY':
                                        offset = new THREE.Vector3(guiMgr.cellWidth * (0.5 + i - guiMgr.brushSize * 0.5), guiMgr.cellWidth * j, guiMgr.cellWidth * (0.5 + k - guiMgr.brushWidth * 0.5));
                                        break;
                                    case 'YZ':
                                        offset = new THREE.Vector3(guiMgr.cellWidth * (0.5 + k - guiMgr.brushWidth * 0.5), guiMgr.cellWidth * i, guiMgr.cellWidth * (0.5 + j - guiMgr.brushSize * 0.5));
                                        break;
                                }
                                rollOverMeshes[guiMgr.brushSize*guiMgr.brushSize * k + guiMgr.brushSize * j + i].position.copy( intersect.point).add(offset).add( intersect.face.normal );
                                rollOverMeshes[guiMgr.brushSize*guiMgr.brushSize * k + guiMgr.brushSize * j + i].position.divideScalar( guiMgr.cellWidth ).floor().multiplyScalar( guiMgr.cellWidth ).addScalar( guiMgr.halfCellWidth );
                            }
                        }
                    }
                    var p = coord2ind(rollOverMeshes[0].position.x, rollOverMeshes[0].position.y, rollOverMeshes[0].position.z);
                    positionText = "(" + p.x + ", " + p.y + ", " + p.z + ")";
                }

                render();
            }

            function onDocumentMouseDown( event ) {
                event.preventDefault();

                mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

                // get world position of camera to raycast from
                cameraPosition.setFromMatrixPosition( camera.matrixWorld );
                raycaster.ray.origin.copy(cameraPosition);
                raycaster.ray.direction.set(mouse.x, mouse.y, 0.5).unproject(camera).sub(cameraPosition).normalize();

                var intersects = raycaster.intersectObjects( objects );

                if ( intersects.length > 0 ) {
                    var intersect = intersects[ 0 ];

                    // delete cube
                    if ( isShiftDown ) {
                        if ( intersect.object != plane ) {
                            scene.remove( intersect.object );
                            objects.splice( objects.indexOf( intersect.object ), 1 );
                        }
                    // create cube
                    } else {
                        // make one voxel for each brush element
                        for (var i = 0; i < rollOverMeshes.length; i++)
                        {
                            var voxel = new THREE.Mesh( cubeGeo, guiMgr.materials[guiMgr.BrushFlag] );
                            voxel.position.copy( rollOverMeshes[i].position );
                            voxel.position.divideScalar( guiMgr.cellWidth ).floor().multiplyScalar( guiMgr.cellWidth ).addScalar( guiMgr.halfCellWidth );
                            voxel.material.color.setHex(guiMgr.colors[guiMgr.BrushFlag]);

                            // don't actually add voxel if it's outside our domain
                            if ((voxel.position.x - guiMgr.halfCellWidth) / guiMgr.cellWidth >= guiMgr.xlength)
                                continue;
                            if ((voxel.position.y - guiMgr.halfCellWidth) / guiMgr.cellWidth >= guiMgr.ylength)
                                continue;
                            if ((voxel.position.z - guiMgr.halfCellWidth) / guiMgr.cellWidth >= guiMgr.zlength)
                                continue;
                            if ((voxel.position.x < 0) || (voxel.position.y < 0) || (voxel.position.z < 0))
                                continue;

                            // store cell data for later export
                            voxel.userData.flag = guiMgr.BrushFlag;     // FLAG

                            // only store parameter data for flags that require it
                            switch (guiMgr.BrushFlag)
                            {
                                case 'MOVING_WALL':
                                    voxel.userData.parms = [guiMgr.parm1, guiMgr.parm2, guiMgr.parm3];
                                    break;
                                case 'INFLOW':
                                    voxel.userData.parms = [guiMgr.parm1, guiMgr.parm2, guiMgr.parm3];
                                    break;
                                case 'PRESSURE_IN':
                                    voxel.userData.parms = [guiMgr.parm1];
                                    break;
                                default:
                                    voxel.userData.parms = [];
                                    break;
                            }

                            scene.add( voxel );
                            objects.push( voxel );
                        }
                    }

                    render();
                }
            }

            function onDocumentDragOver ( event ) {
                event.preventDefault();
            }

            function onDocumentDrop( event ) {
                event.preventDefault();

                for(var i = 0; i < event.dataTransfer.files.length; i++){
                    var file        = event.dataTransfer.files[i];
                    var reader      = new FileReader();
                    reader.onload   = function (event){
                        ImportData( event.target.result )
                    };
                    reader.readAsText(file);
                }
            }

            function onDocumentKeyDown( event ) {
                var rotSpeed = 0.05;
                var movSpeed = 25;
                var cameraDir = new THREE.Vector3(0, 0, -1);
                cameraDir.applyQuaternion(camera.quaternion).setY(0).normalize();
                var cameraRight = new THREE.Vector3(1, 0, 0);
                cameraRight.applyQuaternion(camera.quaternion).normalize();
                switch( event.keyCode ) {

                    case 16: isShiftDown = true; break;
                    case 39:  // right arrow
                        rotateAroundWorldAxis(cameraParent, new THREE.Vector3(0, 1, 0), rotSpeed);
                        break;
                    case 37: // left arrow
                        rotateAroundWorldAxis(cameraParent, new THREE.Vector3(0, 1, 0), -rotSpeed);
                        break;
                    case 38: // up arrow
                        cameraParent.rotateOnAxis(cameraRight, -rotSpeed);
                        break;
                    case 40: // down arrow
                        cameraParent.rotateOnAxis(cameraRight, rotSpeed);
                        break;
                    case 87: // W
                        cameraParent.translateOnAxis(cameraDir, movSpeed);
                        break;
                    case 83: // S
                        cameraParent.translateOnAxis(cameraDir, -movSpeed);
                        break;
                    case 65: // A
                        cameraParent.translateOnAxis(cameraRight, -movSpeed);
                        break;
                    case 68: // D
                        cameraParent.translateOnAxis(cameraRight, movSpeed);
                        break;
                    case 81: // Q
                        camera.translateOnAxis(new THREE.Vector3(0, 1, 0), -movSpeed);
                        //camera.fov *= 1.05;
                        //camera.updateProjectionMatrix();
                        break;
                    case 69: // E
                        camera.translateOnAxis(new THREE.Vector3(0, 1, 0), movSpeed);
                        //camera.fov *= 0.95;
                        //camera.updateProjectionMatrix();
                        break;
                }
                render();
            }

            function onDocumentKeyUp( event ) {
                switch ( event.keyCode ) {
                    case 16: isShiftDown = false; break;
                }
            }

            function updateCameraPos()
            {
                cameraParent.position.set( guiMgr.xlength * guiMgr.halfCellWidth, guiMgr.ylength * guiMgr.halfCellWidth, guiMgr.zlength * guiMgr.halfCellWidth);
            }

            function render() {
                renderer.render( scene, camera );
                document.getElementById('position').innerHTML = positionText;
            }

            function rotateAroundWorldAxis( object, axis, radians ) {
                var rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationAxis( axis.normalize(), radians );
                rotationMatrix.multiply( object.matrix );                       // pre-multiply
                object.matrix = rotationMatrix;
                object.rotation.setFromRotationMatrix( object.matrix );
            }
        </script>

    </body>
</html>
