#include "helper.h"
#include "visualLB.h"
#include "LBDefinitions.h"
#include "computeCellValues.h"

void writeVtkOutput(const double * const collideField, const flag_data * const flagField, const char * filename, unsigned int t, int xlength, int ylength, int zlength) {
  int i,j,k;
  char szFileName[80];
  FILE *fp=NULL;
#ifndef _WIN32 // sprintf is deprecated in favor of sprintf_s on Windows
  sprintf( szFileName, "%s.%i.vtk", filename, t );
  fp = fopen(szFileName, "w");

  if (fp == NULL)
  {
      char szBuff[80];
      sprintf(szBuff, "Failed to open %s", szFileName);
      ERROR(szBuff);
      return;
  }
#else
  sprintf_s(szFileName, 80, "%s.%i.vtk", filename, t);
  errno_t err = fopen_s( &fp, szFileName, "w" );

  if ( err != 0 )
  {
      char szBuff[80];
      sprintf_s(szBuff, "Failed to open %s", szFileName);
      ERROR(szBuff);
      return;
  }
#endif



  // allocate space to store densities so we don't recompute them 
  // when computing the velocity
  double *densities = (double*) malloc(sizeof(double) * (xlength+2)*(ylength+2)*(zlength+2));

  write_vtkHeader( fp, xlength, ylength, zlength);
  write_vtkPointCoordinates(fp, xlength, ylength, zlength, 1, 1, 1);

  // output density values for every inner cell
  fprintf(fp,"\n");
  fprintf(fp,"POINT_DATA %i \n", (xlength)*(ylength)*(zlength) );
  fprintf(fp, "SCALARS density float 1 \n"); 
  fprintf(fp, "LOOKUP_TABLE default \n");
  for(k = 1; k < zlength+1; k++) {
    for(j = 1; j < ylength+1; j++) {
      for(i = 1; i < xlength+1; i++) {
        computeDensity(&collideField[INDEXOF(i,j,k,0)], &densities[FINDEXOF(i,j,k)]);
        fprintf(fp, "%f\n", densities[FINDEXOF(i,j,k)] );
      }
    }
  }

  // output flag values for every inner cell
  fprintf(fp, "\n");
  fprintf(fp, "SCALARS flag float 1 \n"); 
  fprintf(fp, "LOOKUP_TABLE default \n");
  for(k = 1; k < zlength+1; k++) {
    for(j = 1; j < ylength+1; j++) {
      for(i = 1; i < xlength+1; i++) {
        fprintf(fp, "%f\n", (double)flagField[FINDEXOF(i,j,k)].flag);
      }
    }
  }

  // output velocity values for every inner cell
  fprintf(fp,"\n");
  fprintf(fp, "VECTORS velocity float\n");
  for(k = 1; k < zlength+1; k++) {
    for(j = 1; j < ylength+1; j++) {
      for(i = 1; i < xlength+1; i++) {
        double velocity[3];
        computeVelocity(&collideField[INDEXOF(i,j,k,0)], densities+FINDEXOF(i, j, k), velocity);
        fprintf(fp, "%f %f %f\n", velocity[0], velocity[1], velocity[2]);
      }
    }
  }

  // cleanup
  free(densities);

  if( fclose(fp) )
  {
    char szBuff[80];
#ifndef _WIN32 // sprintf is deprecated in favor of sprintf_s on Windows
    sprintf( szBuff, "Failed to close %s", szFileName );
#else
    sprintf_s( szBuff, 80, "Failed to close %s", szFileName );
#endif
    ERROR( szBuff );
  }
}

void write_vtkHeader( FILE *fp, int xlength, int ylength, int zlength)
{

  if( fp == NULL )
  {
    char szBuff[80];
#ifndef _WIN32 // sprintf is deprecated in favor of sprintf_s on Windows
    sprintf( szBuff, "Null pointer in write_vtkHeader" );
#else
    sprintf_s( szBuff, 80, "Null pointer in write_vtkHeader" );
#endif
    ERROR( szBuff );
    return;
  }

  fprintf(fp,"# vtk DataFile Version 2.0\n");
  fprintf(fp,"generated by CFD-lab course output (written by Tobias Neckel) \n");
  fprintf(fp,"ASCII\n");
  fprintf(fp,"\n");	
  fprintf(fp,"DATASET STRUCTURED_GRID\n");
  fprintf(fp,"DIMENSIONS  %i %i %i\n", xlength, ylength, zlength);
  fprintf(fp,"POINTS %i float\n", (xlength)*(ylength)*(zlength) );
  fprintf(fp,"\n");
}


void write_vtkPointCoordinates( FILE *fp, int xlength, int ylength, int zlength, double dx, double dy, double dz)
{
  double originX = 0.0;
  double originY = 0.0;
  double originZ = 0.0;

  int i = 0;
  int j = 0;
  int k = 0;

  // generate equal-spaced grid points
  for(k = 0; k < zlength; k++) {
    for(j = 0; j < ylength; j++) {
      for (i = 0; i < xlength; i++) {
        fprintf(fp, "%f %f %f\n", originX+(i*dx), originY+(j*dy), originZ+(k*dz) );
      }
    }
  }
}

